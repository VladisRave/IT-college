# **Блок 3: Запросы и анализ производительности (Третья пара)**

## **Введение**
База данных создана и заполнена. Теперь наша задача — "спрашивать" у нее информацию. Мы напишем полезные запросы (SQL DML) и, что самое важное, обсудим, как структура базы данных и наши запросы влияют на скорость их выполнения и нагрузку на аппаратное обеспечение сервера.

**Ключевой вопрос пары:** "Как эффективно получать данные и почему одни запросы быстрые, а другие — медленные?"

---

#### **Этап 4: Тестирование и выполнение запросов**

**Что делаем:** Напишем несколько запросов разной сложности, чтобы извлечь полезную информацию из нашей базы.

**Практическое задание:**

1.  **Простой запрос:** Вывести список всех компьютеров.
    ```sql
    SELECT * FROM computers;
    ```

2.  **Запрос с фильтрацией (WHERE):** Найти все компьютеры с объемом ОЗУ больше 8 ГБ.
    ```sql
    SELECT id, model, ram_gb
    FROM computers
    WHERE ram_gb > 8;
    ```

3.  **Запрос с соединением таблиц (JOIN):** Вывести красивый отчет с полной информацией о компьютерах, включая название аудитории и модель процессора.
    ```sql
    SELECT
        comp.id AS "Инвентарный номер",
        comp.model AS "Модель компьютера",
        proc.model AS "Процессор",
        loc.name AS "Местоположение"
    FROM computers comp
    JOIN locations loc ON comp.location_id = loc.id
    JOIN processors proc ON comp.processor_id = proc.id;
    ```
    *   **Объяснение:** `JOIN` позволяет "склеить" данные из нескольких таблиц по совпадающим значениям ключей (`loc.id` и `comp.location_id`).

---

#### **Этап 5. Связь с архитектурой аппаратных средств (Аналитическая часть)**

Теперь самое время поговорить о "магии" под капотом. Почему наши запросы выполняются быстро или медленно?

**Что делаем:** Анализируем, как наши решения при проектировании влияют на нагрузку на компоненты сервера.

**Обсуждение на примерах:**

1.  **Жесткий диск (HDD/SSD) vs Оперативная память (RAM):**
    *   **Проблема:** Запрос `SELECT * FROM computers WHERE ram_gb > 8` заставляет сервер прочитать с диска всю таблицу `computers`. Если таблица огромная (миллионы строк), это медленно, особенно на HDD.
    *   **Решение: ИНДЕКСЫ.**
        *   **Что это?** Индекс — это как оглавление в книге. Он создает отдельную упорядоченную структуру для определенного столбца (например, `ram_gb`), которая хранится в оперативной памяти.
        *   **Как создать?** `CREATE INDEX idx_computers_ram ON computers(ram_gb);`
        *   **Анализ:** Теперь сервер не будет читать всю таблицу с диска, а быстро найдет нужные строки по "оглавлению" в памяти. Это сильно снижает нагрузку на диск и ускоряет запрос.

2.  **Процессор (CPU):**
    *   **Проблема:** Сложные запросы с множеством `JOIN`, агрегатные функции (`COUNT`, `SUM`), сортировка (`ORDER BY`) требуют интенсивных вычислений. Это нагрузка на процессор.
    *   **Решение:**
        *   **Правильное проектирование:** Нормализация базы данных (как у нас) избегает избыточности и уменьшает объем данных, которые нужно обрабатывать.
        *   **Оптимизация запросов:** Избегайте `SELECT *`, если нужны не все колонки. Указывайте только нужные поля (`SELECT id, model...`). Это уменьшает объем данных, пересылаемых между диском, памятью и процессором.

3.  **Оперативная память (RAM):**
    *   **Проблема:** Чем больше индексов и чем чаще используются данные, тем больше оперативной памяти нужно серверу, чтобы хранить их для быстрого доступа.
    *   **Вывод:** Проектируя БД, мы постоянно идем на компромисс: добавляя индекс, мы ускоряем чтение, но расходуем больше оперативной памяти.

**Практическое задание (аналитическое):**
1.  Объясните, какой компонент сервера (Диск, Память, Процессор) будет загружен сильнее всего при выполнении запроса с `JOIN` из предыдущего примера? Почему?
2.  Предложите, для каких полей в нашей базе данных было бы полезно создать индексы, кроме `ram_gb`? (Подсказка: подумайте, по каким полям мы часто ищем, например, `location_id` или `processor_id` в запросах с `JOIN`).

---

### **Итоговый вывод по курсу (Простыми словами)**

Представьте, что база данных — это библиотека.
*   **Проектирование таблиц (ER-диаграмма)** — это план расстановки стеллажей и полок по жанрам и алфавиту. Хороший план помогает быстро найти нужную книгу.
*   **SQL-запросы** — это ваш запрос библиотекарю: "Принесите, пожалуйста, все фантастические романы, изданные после 2020 года".
*   **Индексы** — это картотечный каталог в библиотеке. Без каталога библиотекарю пришлось бы обойти все стеллажи (полная нагрузка на ноги — **Диск**). С каталогом он сразу идет к нужной полке (быстро, нагрузка на мозг — **Память/Процессор**).
*   **Аппаратное обеспечение** — это сама библиотека: размер здания (**Диск**), скорость библиотекаря (**Процессор**) и размер читального зала, где лежат популярные книги (**Оперативная память**).

**Вывод:** Неэффективно спроектированная база данных (плохой план библиотеки) будет медленно работать даже на самом мощном сервере (огромной библиотеке с быстрыми библиотекарями). И наоборот, грамотно спроектированная БД позволит эффективно использовать ресурсы даже не самого нового "железа". Мы должны думать о производительности на этапе проектирования!